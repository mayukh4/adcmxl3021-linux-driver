// Decompiled with JetBrains decompiler
// Type: FX3Api.I2CPreamble
// Assembly: FX3Api, Version=2.9.5.0, Culture=neutral, PublicKeyToken=null
// MVID: 12B0FED1-476B-4D9A-A704-DBE530C65588
// Assembly location: C:\Users\bagch\OneDrive\Documents\Mayukh_misc\adcmxl_evaluation_rev_2192\FX3Api.dll
// XML documentation location: C:\Users\bagch\OneDrive\Documents\Mayukh_misc\adcmxl_evaluation_rev_2192\FX3Api.xml

using System.Collections.Generic;

#nullable disable
namespace FX3Api;

/// <summary>I2C pre-amble class.</summary>
public class I2CPreamble
{
  private byte m_addr;
  private byte m_stopMask;
  private byte m_startMask;
  /// <summary>
  /// The bytes to transmit following the device address and R/W bit.
  /// The maximum size of this list is 7 bytes, giving 8 total bytes
  /// transmitted as part of the pre-amble.
  /// </summary>
  public List<byte> PreambleData;

  /// <summary>I2C Preamble constructor. Initializes all fields to zero</summary>
  public I2CPreamble()
  {
    this.PreambleData = new List<byte>();
    this.m_addr = (byte) 0;
    this.m_stopMask = (byte) 0;
    this.m_startMask = (byte) 0;
  }

  /// <summary>
  /// This is the 7-bit slave address for the device to access on the I2C bus.
  /// The address value must be left justified, with a zero in the least significant
  /// bit. The address bits (starting at DeviceAddress bit 7) are the first data transmitted
  /// by the FX3 when starting an I2C transaction. A R/W bit (generated by the firmware)
  /// follows the seven device address bits to complete the first byte.
  /// </summary>
  /// <returns></returns>
  public byte DeviceAddress
  {
    get => this.m_addr;
    set => this.m_addr = checked ((byte) ((int) value & 254));
  }

  /// <summary>
  /// This field controls the stop condition sent after every byte of preamble
  /// data. The device address is the first byte of data, following by up to
  /// seven additional bytes in PreAmbleData. For example, setting StopMask to
  /// 0x01 will cause a stop condition to be generated after sending DeviceAddress, while
  /// setting StopMask to 0x02 will cause a stop condition to be generated after
  /// sending PreambleData[0], and so on. Note, setting a bit in StopMask will cause
  /// the corresponding bit in StartMask to be cleared, if it is also set.
  /// </summary>
  /// <returns>The 8 bit preamble stop mask</returns>
  public byte StopMask
  {
    get => this.m_stopMask;
    set
    {
      this.m_stopMask = value;
      this.m_startMask &= ~this.m_stopMask;
    }
  }

  /// <summary>
  /// This field controls the start condition sent after every byte of preamble
  /// data. The device address is the first byte of data, following by up to
  /// seven additional bytes in PreAmbleData. For example, setting StartMask to
  /// 0x04 will cause a start condition to be generated after sending PreambleData[1], while
  /// setting StartMask to 0x08 will cause a start condition to be generated after
  /// sending PreambleData[2], and so on. Note, setting a bit in StartMask will cause
  /// the corresponding bit in StopMask to be cleared, if it is also set.
  /// </summary>
  /// <returns>The 8 bit preamble start mask</returns>
  public byte StartMask
  {
    get => this.m_startMask;
    set
    {
      this.m_startMask = value;
      this.m_stopMask &= ~this.m_startMask;
    }
  }

  /// <summary>
  /// Helper function to serialize an I2C preamble. Puts the
  /// preamble into a byte array which can be sent over USB
  /// </summary>
  /// <returns>Byte array containing the pre-amble</returns>
  internal IEnumerable<byte> Serialize()
  {
    List<byte> byteList = new List<byte>();
    int num = checked (this.PreambleData.Count + 1);
    if (num > 8)
      num = 8;
    byteList.Add(checked ((byte) num));
    byteList.Add(this.StartMask);
    byteList.Add(this.StopMask);
    byteList.Add(this.DeviceAddress);
    if (this.PreambleData.Count > 7)
      this.PreambleData.RemoveRange(7, checked (this.PreambleData.Count - 7));
    byteList.AddRange((IEnumerable<byte>) this.PreambleData);
    return (IEnumerable<byte>) byteList;
  }
}
